import tensorflow as tf

class TreeNN():
  def __init__(self, cell, parser, batch_size):
    self.cell = cell
    self.parser = parser
    self.batch_size = batch_size

    self.variables = self.cell.variables

  def __call__(self, w, trees):
    """
    Applies `self.cell` according to the tree(s) generated by `self.parser`.

    Args:
      w: a world
      trees (list): stacked outputs of self.parser

    Returns: (batch_size x cell.output_size)
    """
    # a stack for keeping track of computed nodes
    states = []

    lens = [len(ops) for ops, _ in trees]
    # depth first traversal across all the trees in the batch
    for i in range(max(lens)):
        locs_n_ops_n_args = []
        for j, opsnargs in enumerate(trees):  # each element of our batch
            ops, args = opsnargs
            if i<len(ops):  # make sure we dont try to index out of range
                args[i] = [i+a for a in args[i]]  # relative to abs
                locs_n_ops_n_args.append((j, ops[i], args[i]))

        state = self.cell(states, locs_n_ops_n_args)
        states.append(state)

    return states[-1]
